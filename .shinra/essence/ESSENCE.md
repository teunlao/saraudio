---
agent: codex
product: ESSENCE
updated: 2025-12-15
iteration: 3
---

# SARAUDIO — ESSENCE

> Агент: codex
> Обновлено: 15 декабря 2025
> Статус: draft (filled)

## Что это

SARAUDIO — модульный аудио‑стек для AI‑voice приложений в JavaScript/TypeScript.

Он закрывает «склейку» проблем, которые обычно пользователи решают сами:

- захват аудио в браузере и Node с предсказуемой задержкой;
- модель «источников»: захват — заменяемый слой (микрофон сейчас; архитектура рассчитана на расширение к другим источникам);
- real‑time обработку в виде расширяемого конвейера (stages);
- VAD + устойчивую сегментацию речи (pre‑roll / hangover);
- сбор выходов, полезных для моделей (cleaned/full/masked);
- унификацию провайдеров транскрипции (WS/HTTP) так, чтобы смена провайдера не требовала переписывать приложение.

## Для кого

- Продуктовые команды, делающие voice UX в браузере (ассистенты, диктовка, формы, звонки).
- Разработчики, которым нужен контроль: latency, сегменты, политика тишины, метрики.
- Команды, которые не хотят vendor lock‑in в STT (Deepgram/Soniox/…).

## Слои и направления зависимостей (сверху вниз)

Смысл слоёв: ядро остаётся платформенно‑агностичным и расширяемым, а окружение и провайдеры «подключаются» сверху.

1) **Utils (самый низкий слой)**
- `@saraudio/utils`: DSP‑утилиты, async/таймеры/логгер, мелкие строительные блоки.

2) **Core (домен и контракты)**
- `@saraudio/core`: событийный pipeline, модель стадий, сегментация, сбор записей, базовые контракты транскрипции.

3) **Processing plugins (опциональные стадии)**
- `@saraudio/vad-energy`: VAD как плагин/stage.
- `@saraudio/meter`: измерение уровня/метрики входа как плагин/stage.

4) **Runtime (окружение, источники аудио, удобные фасады)**
- `@saraudio/runtime-browser`: захват в браузере + сборка recorder поверх core.
- `@saraudio/runtime-node`: Node‑утилиты/рантайм (server‑side стриминг/батчи, helpers).

5) **Transcription orchestration (средний слой между recorder и provider)**
- `@saraudio/runtime-base`: контроллер транскрипции, выбор транспорта (WS/HTTP), политика тишины, preconnect‑буфер, retry.

6) **Providers (vendor adapters)**
- `@saraudio/deepgram`, `@saraudio/soniox`: адаптеры провайдеров, каждый объявляет возможности и поддерживаемые транспорты.

7) **UI bindings**
- `@saraudio/react`, `@saraudio/vue`, `@saraudio/svelte`, `@saraudio/solid`: тонкие биндинги, которые управляют жизненным циклом recorder/controller и отражают события в состоянии UI.

## Ключевые концепции (в терминах «как устроено»)

### Pipeline + Stages

- Система устроена как конвейер: входные аудио‑кадры проходят через набор стадий.
- Стадии не «возвращают результат» напрямую — они генерируют события домена (например, VAD‑события, границы речи, сегменты, метрики, ошибки).
- Pipeline поддерживает безопасную динамическую переконфигурацию: набор стадий обновляется атомарно, без промежуточных «частично настроенных» состояний.

### Segmenter

- Сегментация отделена от VAD: VAD сообщает «похоже на речь», а сегментатор формирует устойчивые границы.
- Два ключевых рычага, которые определяют качество UX:
  - **pre‑roll** — не терять начало фразы;
  - **hangover** — не резать конец на микропаузах.

### Recorder (уровень «для приложений»)

- Recorder склеивает runtime‑источник + pipeline + сегментатор + сбор записей.
- Recorder — это точка, где аудио «превращается» в:
  - поток событий для UI (VAD/segment/meter/status/error);
  - готовые записи, пригодные для дальнейшей обработки/отправки.

### Transcription controller (оркестрация STT)

- Контроллер соединяет recorder (как источник нормализованных кадров) с provider’ом (как получателем/интерпретатором).
- Его задача — сделать потоковую транскрипцию предсказуемой:
  - выбрать транспорт (WebSocket vs HTTP) по возможностям и настройкам;
  - буферизовать ранние кадры, чтобы не терять начало речи на handshake;
  - управлять политикой тишины (keep/drop/mute);
  - ретраить временные ошибки без того, чтобы приложение писало свой state machine.

### Provider abstraction

- Провайдеры объявляют возможности (partials/words/diarization/force‑endpoint/… и поддерживаемые транспорты).
- Нового провайдера можно добавить без изменения application‑кода: приложение работает через единый контракт и общий controller.

## Основные флоу (data flow)

### 1) Browser capture → VAD/segments → recordings

1. Runtime в браузере выбирает режим захвата (низкая задержка vs совместимость).
2. Источник выдаёт непрерывный поток кадров (PCM) в core‑конвейер.
3. Стадии обогащают поток событиями (VAD/метр/ошибки).
4. Сегментатор превращает VAD‑сигнал в «речевые сегменты».
5. Recorder собирает выходы:
   - **full**: весь поток;
   - **cleaned**: только речь (сшивка сегментов);
   - **masked**: весь поток, но тишина занулена.

### 2) Recorder → (WS/HTTP) → transcripts

1. Recorder поставляет нормализованные кадры и события (включая сегменты).
2. Контроллер транскрипции соединяется с провайдером:
   - в WS режиме: постоянный стрим кадров + политика тишины;
   - в HTTP режиме: чанкинг/агрегация и отправка батчами.
3. Контроллер транслирует наружу два потока данных:
   - «частичные» обновления (если провайдер поддерживает);
   - финальные транскрипты (плюс метаданные/таймкоды при наличии).

## Инварианты (то, что нельзя ломать)

- **Не терять кадры при (ре)конфигурации**: pipeline должен безопасно принимать кадры до полной готовности и применять конфигурацию атомарно.
- **Границы окружений**: core не должен зависеть от браузерных/Node‑глобалов на уровне импорта; окруженческий код живёт в runtime‑пакетах.
- **DI без контейнера**: зависимости передаются явно (логгер, часы, генерация id и т.п.), без глобальных синглтонов.
- **Расширение без правки ядра**: новая логика добавляется как stage/plugin или provider, а не через ветвления в core.
- **Fallback без сюрпризов**: браузерный runtime обязан объяснимо выбирать режим и давать приложение‑уровню сигнал о деградации (latency/качество/ограничения).

## Tradeoffs и ограничения исполнения

- **Worklet‑режим**: минимальная задержка и лучший контроль, но требует условий безопасности (cross‑origin isolation) и поддержки браузером.
- **MediaRecorder‑режим**: максимально совместим, но добавляет задержку и зависит от поведения кодеков/браузера.
- **Микрофон/девайсы**: пермишены, различия в sampleRate/channels между устройствами и браузерами — runtime обязан быть «слоем совместимости», а не прокидывать проблемы вверх молча.

## Как проект «растёт» (модель расширения)

- Добавить обработку: написать новую stage (или controller‑обёртку), подключить в pipeline.
- Добавить провайдера STT: реализовать provider adapter и объявить capabilities/transports; переиспользовать общий transcription controller.
- Добавить UI‑интеграцию: сделать тонкий binding‑слой, который держит долгоживущие объекты стабильно (не пересоздаёт pipeline/recorder на каждый ререндер) и корректно чистит async‑эффекты.

— codex
