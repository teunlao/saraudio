SARAUDIO · Нормализация аудио и DX‑контракты (черновик)

1) Базовый принцип
- Если пользователь запрашивает целевой формат (например, 16 кГц моно PCM16), а браузер фактически отдаёт другой (чаще 48 кГц), библиотека сама приводит поток к целевому формату. Пользователь не думает о частотах и ресемплинге.

2) Зачем это делаем
- Совместимость с ASR: многие провайдеры ожидают 16 кГц моно PCM16.
- Предсказуемый опыт: «задал цель → получил ровно это» независимо от браузера/устройства.
- Экономия трафика и стоимости: 16 кГц ≈ в 3 раза легче 48 кГц.

3) Где происходит конвертация (слои)
- Захват (ядро): работаем с «родной» частотой AudioContext (обычно 48 кГц) — не трогаем, чтобы не мешать внутренним стадиям (VAD, meter).
- Нормализация на выходе (наша ответственность): перед отправкой наружу или в транспорт выполняем
  • даунмикс → моно,
  • конвертацию → PCM16,
  • ресемплинг → целевая частота (по умолчанию 16 кГц для ASR).

4) Политика по умолчанию
- «ASR‑профиль» по умолчанию: моно, PCM16, 16 кГц.
- Если конкретный провайдер официально поддерживает иной формат (напр., 48 кГц) и это выгодно — адаптер может пропускать без ресемплинга (pass‑through). Решение — внутри библиотеки, не на пользователе.

5) Два уровня API (сосуществуют)
- Продвинутый (как сегодня): доступ к «сырым» кадрам и полному контролю (subscribeRawFrames, Pipeline/Stage).
- Упрощённый (будущие провайдеры): «подключи провайдера, укажи ключ, старт». Вся сложность (форматы, буферы старта, ретраи, закрытие) скрыта внутри.

6) Совместимость и контракты
- Стабильное ядро не меняет семантику: кадры, события, стадии, сегменты.
- Провайдеры — тонкая надстройка над Recorder, без глобальных скрытых состояний.
- Можно одновременно использовать ручной путь и провайдер, они не конфликтуют.

7) Текущее состояние vs целевое
- Сейчас: библиотека не ресемплирует; браузер чаще отдаёт 48 кГц. Пример делает конвертацию/даунсемпл «вручную» в composable — это временно.
- Цель: перенести конверсию и ресемплинг «под капот» (универсальный выходной адаптер/опции подписки), чтобы пример стал декларативным и не содержал DSP‑логики.

8) Ошибки и безопасность
- Понятные статусы и действия: «подключаюсь → поток открыт → ошибка/закрыт» с короткими советами что делать.
- Ключи провайдеров не светятся в логах/URL; диагностика без компрометации секретов.

Статус: черновик принципов; реализация — вынести ресемплинг/нормализацию из примеров в библиотеку (адаптер или опции подписки) без ломки существующего ручного пути.

---

Мини‑план DX: замена constraints на source.microphone

Цель (минимум, без ломки): убрать из публичного DX браузерные термины и сделать выбор микрофона человекопонятным.

Публичное API (новое)
- `source: { microphone: { deviceId?: string } }`
- Приоритет: если переданы и `source`, и `constraints` → используется `source`.

Deprecated
- `constraints` (тип `MediaTrackConstraints`/`getUserMedia`‑стиль) — помечаем как deprecated и планируем удалить в ближайшем минор‑→мажор цикле.
- Временная совместимость: поддерживаем ещё 1–2 минорных релиза, отображаем предупреждение в доке (и опционально в рантайме).

Поведение
- Внутри маппим `source.microphone.deviceId` в `deviceId: { exact: ... }` для реального вызова `getUserMedia`.
- Никаких новых низкоуровневых флагов (echoCancellation/NS/AGC) в публичном API сейчас не добавляем.

Шаги внедрения
1) runtime-browser
   - Расширить `RecorderOptions` полем `source?: { microphone?: { deviceId?: string } }` (packages/runtime-browser/src/types.ts, recorder.ts).
   - При создании источника: если есть `source.microphone` → сконструировать `MediaTrackConstraints` внутри; иначе — использовать старое `constraints` (advanced).
2) vue
   - В `useRecorder` добавить проп `source?: { microphone?: { deviceId?: string } }` и прокидывать в `createRecorder`.
   - Следить за изменениями `source` в `watch` как за прочими опциями.
3) примеры
   - Заменить использование `buildAudioConstraints(...)` на `source: { microphone: { deviceId } }`.
   - Убрать вызовы `buildAudioConstraints` из примеров/доков.
4) документация
   - README (runtime-browser/vue): раздел “Источник звука” с новым API.
   - Явно пометить `constraints` как deprecated и срок удаления.
5) тесты (минимум)
   - Юнит: приоритет `source` над `constraints`.
   - Юнит: корректный маппинг `deviceId` → constraints.

Семантика и будущее
- Сейчас меняем только ввод (как указать микрофон).
- В следующей фазе добавим `format` (целевой sampleRate/channels/encoding) с автоматической нормализацией под капотом.

Депрекейшн‑график
- vNext (minor): добавить новое поле `source`, задокументировать deprecated `constraints`.
- vNext+1 (minor): оставить поддержку, но вынести более явное предупреждение в доку/CHANGELOG.
- Следующий major: удалить `constraints` из публичного API.

---

API Форма: параллельные поля source и format

Принцип
- `source` отвечает за то, ЧТО захватываем; `format` — за то, КАКИМ аудио хотим оперировать «снаружи». Поля параллельные (не вложены), чтобы один и тот же формат можно было применять к разным источникам.

Публичное API (цель)
- `source: 'microphone' | { microphone?: { deviceId?: string } } | 'system' | { system?: true }`
- `format: { sampleRate?: number; channels?: 1 | 2; encoding?: 'pcm16' }`
  • дефолт (ASR‑профиль): `{ sampleRate: 16000, channels: 1, encoding: 'pcm16' }`

Семантика
- `source` выбирает источник (сегодня — микрофон; далее — системный звук). Никаких браузерных констрейнтов в публичном DX.
- `format` — гарантированный внешний формат для подписок/транспорта. Нормализация (даунмикс/ресемплинг/приведение к PCM16) происходит под капотом.
- Пайплайн (VAD/метр/сегментер) может работать на «родной» частоте для точности; снаружи выдаём нормализованный формат.

Подписки (ровно два метода)
- `subscribeFrames(handler)` — базовый поток. Всегда возвращает кадры в целевом формате из `format` (по умолчанию 16 kHz, mono, pcm16).
- `subscribeRawFrames(handler)` — продвинутый поток. Возвращает «как есть» от источника (часто 48 kHz), без нормализации.

Приоритеты и дефолты
- Если `source` не указан — используем системный микрофон.
- Если `format` не указан — применяем ASR‑профиль по умолчанию.
- `source/format` имеют приоритет над устаревшим `constraints`.

План внедрения (после `source`)
1) Ввести `format` в Recorder/useRecorder и прокинуть в runtime-browser (minor).
2) Реализовать нормализацию под капотом: даунмикс каналов, ресемплинг, PCM16 (minor).
3) Добавить поддержку `source: { system: true }` (минимальный UX: диалог выбора окна/вкладки) — отдельный minor.
4) Документация и примеры: перейти на `format` и `subscribeFrames`, убрать ручной ресемплинг из примеров.

---

Vue Hook (`useRecorder`) · выравнивание DX

Проблема
- Двойное обращение `rec.recorder` — это проблема слоя хука, не runtime-browser. Пользовательский DX страдает из-за необходимости лезть во внутренний объект и работать через `.value`.

Решение (плоский API хука)
- На верхнем уровне возвращаем сразу:
  • `start()`, `stop()`, `status`, `error`, `pipeline`, `recordings`.
  • `subscribeFrames(handler)`, `subscribeRawFrames(handler)`, `onReady(handler)`.
- Внутренний `Recorder` прячем; для продвинутых сценариев опционально даём `getRecorder()` (без экспонирования `rec.recorder`).
- Следим за изменениями `source` и `format` реактивно (как сейчас делали для `constraints`).

Итог для примеров
- Меняем вызовы на `rec.subscribeFrames(...)`/`rec.subscribeRawFrames(...)` без `rec.recorder` и без `.value`.

Реализация · 4 ноября 2025
- `@saraudio/utils`: вынесены `downmixToMono`, `resampleLinear`, добавлены юнит-тесты на ресемплинг и даунмикс.
- `@saraudio/core`: общий `cloneFrame/normalizeFrame` с опциями (`format`, `logger`), экспортирован из пакета.
- `@saraudio/runtime-browser`: поддержка `format` в опциях/`update`, новые `subscribeFrames` (нормализованные кадры), `onReady`, стартовый буфер (5 кадров), использование core-нормализации. `subscribeRawFrames` сохранён без изменений.
- `@saraudio/runtime-node`: зеркальные `format`, `subscribeFrames`, `onReady`, буфер и нормализация через core-хелперы.
- `@saraudio/vue`: хук возвращает плоский API (`subscribeFrames`, `subscribeRawFrames`, `subscribeSpeechFrames`, `onReady`, `update`), принимает `format`, удалено обращение `rec.recorder` из DX.
- Nuxt Deepgram пример: подключён `format: { sampleRate: 16000, encoding: 'pcm16' }`, переход на `subscribeFrames`, убран ручной ресемплинг/Float→Int16 конвертер из примера. WebSocket клиент теперь ожидает готовые 16 кГц кадры.
- `useDeepgramRealtime`: функция `sendPcm16` не выполняет DSP; проверяет частоту и отправляет chunk напрямую.
- Все затронутые пакеты прошли `typecheck → lint → test` (utils/core/runtime-browser/runtime-node/vue/nuxt-audio-recorder).
- TODO: держим `constraints` до следующего минорного релиза (помечено комментариями `// TODO remove`), запланировать удаление после коммуникации в релиз-нотах.
